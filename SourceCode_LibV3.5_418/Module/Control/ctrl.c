/****************************************************************
 Copyright (C),2014-2016,SZZKJ Technology
 File name:     ctrl.c
 Author:        WangFeng
 Version:       1.00
 Date:          2015-11-21
 Description:   
 
 Others:        
 
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 History
 ----------------------------------------------------------------
 Index:         1
 Date:          2015-11-21
 Author:        WangFeng
 Modification:  Create this file
****************************************************************/
/*Include files -----------------------------------------------*/
#include "ctrl.h"
#include "stm32f10x_tim.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_adc.h"
#include "db.h"
#include "display.h"


/*Defines -----------------------------------------------------*/
#define SCL1_H()                
#define SCL1_L()

#define SDA1_H()
#define SDA1_L()

#define GET_BT_S_P()            (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_9))
#define GET_BT_S_N()            (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_10))
#define GET_AC_OFF()            GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_4)
#define GET_AC_LOW()            (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_5))
#define SET_MOS_ON()            GPIO_SetBits(GPIOA, GPIO_Pin_8)
#define SET_MOS_OFF()           GPIO_ResetBits(GPIOA, GPIO_Pin_8)
#define SET_RY_INHI_ON()        GPIO_SetBits(GPIOA, GPIO_Pin_3)
#define SET_RY_INHI_OFF()       GPIO_ResetBits(GPIOA, GPIO_Pin_3)
#define SET_FAN_ON()            GPIO_SetBits(GPIOB, GPIO_Pin_12)
#define SET_FAN_OFF()           GPIO_ResetBits(GPIOB, GPIO_Pin_12)
#define SET_RY_OUT_ON()         GPIO_SetBits(GPIOB, GPIO_Pin_15)
#define SET_RY_OUT_OFF()        GPIO_ResetBits(GPIOB, GPIO_Pin_15)
#define SET_POWER_ON()          GPIO_SetBits(GPIOC, GPIO_Pin_6)
#define SET_POWER_OFF()         GPIO_ResetBits(GPIOC, GPIO_Pin_6)

#define PWM_VAL_MAX                 9600
#define PWM_STEP_VAL                (PWM_VAL_MAX/100)

#define ADC_CHN_KEY                 0
#define ADC_CHN_I_SET               1
#define ADC_CHN_C_SET               2
#define ADC_CHN_CHR_I               8
#define ADC_CHN_V_SEL_TEST          9
#define ADC_CHN_VTM1                10
#define ADC_CHN_VTM2                11
#define ADC_CHN_V_BAT               12
#define ADC_CHN_V_OUT               13
#define ADC_CHN_BAT_VP              14
#define ADC_CHN_BAT_VN              15

#define KEY_CODE_K1                     0x01
#define KEY_CODE_K2                     0x02
#define KEY_CODE_K3                     0x03
#define KEY_CODE_K4                     0x04

#define KEY_FILTER_TL                   5
#define KEY_DOWN_LEN_120MS              12
#define KEY_PRESS_LEN_1S                100
#define KEY_PRESS_LEN_2S                200
#define KEY_PRESS_LEN_3S                300
#define KEY_PRESS_LEN_5S                500
#define KEY_REPEAT_BEGIN_TL             15
#define KEY_REPEAT_SPACE                30

#define VOLTAGE_TYPE_NUM                4
#define CURRENT_TYPE_NUM                6

#define STATE_FILT_CNT                  5

#define STATE_FILT(bState,cnt,getState)                                 \
                                if (bState)\
                                {\
                                    if (!getState())\
                                    {\
                                        cnt++;\
                                        if (cnt >= STATE_FILT_CNT)\
                                        {\
                                            cnt = 0;\
                                            bState = FALSE;\
                                        }\
                                    }\
                                    else\
                                    {\
                                        cnt = 0;\
                                    }\
                                }\
                                else\
                                {\
                                    if (getState())\
                                    {\
                                        cnt++;\
                                        if (cnt >= STATE_FILT_CNT)\
                                        {\
                                            cnt = 0;\
                                            bState = TRUE;\
                                        }\
                                    }\
                                    else\
                                    {\
                                        cnt = 0;\
                                    }\
                                }

enum Key_e
{
    E_KC_NOKEY = 0,
    E_KC_UP,
    E_KC_DOWN,
    E_KC_BACK,
    E_KC_SURE,
    E_KC_MAX,
    E_KC_UNDEF = 0xff
} ;


enum ADCIndex_e
{
    E_ADC_INDEX_CHR_I = 0,
    E_ADC_INDEX_VTM1,
    E_ADC_INDEX_VTM2,
    E_ADC_INDEX_V_BAT,
    E_ADC_INDEX_V_OUT,
    //E_ADC_INDEX_BAT_VP,
    //E_ADC_INDEX_BAT_VN,
    E_ADC_INDEX_MAX
};



/*Extern data & funtion----------------------------------------*/

/*Global data -------------------------------------------------*/
U8 byState = CTRL_STATE_IDLE;
U8 byChgStep = CHARGE_STEP_PREV;
U8 byErr = ERROR_NO_ERROR;
BOOL bPowerUp = FALSE;
BOOL bFirst = FALSE;
BOOL bChgDisable = FALSE; /* 禁止进入充电状态标志 */
U8 bySWCnt = 0;
BOOL bTurnOn = FALSE;
BOOL bTurnOff = FALSE;
U16 wdPwrCnt = 0;
BOOL bADC = TRUE; /* 进行ADC转换 */
U8 byADCCnt = 0;

U8 byVolFiltCnt = 0;
U8 byCurrFiltCnt = 0;

const U8 abyADCChn[E_ADC_INDEX_MAX] = 
{
    8,
    10,
    11,
    12,
    13//,
    //14,
    //15
};

U16 awdADCValSample[E_ADC_INDEX_MAX];
U16 awdADCMax[E_ADC_INDEX_MAX];
U16 awdADCMin[E_ADC_INDEX_MAX];
U32 adwdADCSum[E_ADC_INDEX_MAX];
U16 awdADCVal[E_ADC_INDEX_MAX];

U16 wdUPwm = 0;
U16 wdIPwm = 0;
U16 wdICurPwm = 0;
BOOL bTest = FALSE;
BOOL bPCConnect = FALSE;
BOOL bBTP = FALSE;
BOOL bBTN = FALSE;
BOOL bACLow = FALSE;
BOOL bACOff = FALSE;
BOOL bTem1Hi = FALSE;
BOOL bTimerPu = FALSE;

BYTE ISet = 0;
BYTE CSet = 0;

BOOL bSWRyInhi = FALSE;
BOOL bSWRyOut = FALSE;
BOOL bSWMosOn = FALSE;
BOOL bSWFanOn = FALSE;
BOOL bSWPowerON = FALSE;

U16 wdUPwmLast = 0;
U16 wdIPwmLast = 0;

BOOL bSWRyInhiLast = FALSE;
BOOL bSWRyOutLast = FALSE;
BOOL bSWMosOnLast = FALSE;
BOOL bSWFanOnLast = FALSE;
BOOL bSWPowerONLast = FALSE;


BOOL bLEDR = FALSE;
BOOL bLEDY = FALSE;
BOOL bLEDG = FALSE;

uint64_t dwdCapacity;   /* 容量 */
CHAR cTemp1;
CHAR cTemp2;
U16 wdOutVoltage;
U16 wdBtVoltage;
U16 wdCurrent;
U16 wdLastCurrent; /* 上一个电流值，计算电量时用 */
U16 wdVoltCalib = 2353*4095/3300;
U16 wdCurCalib = 13*4095/33;
U8 byVoltType = 0;
U8 byCurType = 0;
U8 byCSetType = 0;
BOOL bGetVal = FALSE;
U8 bySaveUITCnt = 0;
U8 byBTTestCnt = 0;
U8 byJudgeWaitCnt = 0;

const U16 awdVoltTypeValue[VOLTAGE_TYPE_NUM] = {1200, 2400, 3600, 4800};
const U16 awdCurTypeValue[CURRENT_TYPE_NUM] = {500, 1000, 1500, 2000,2500,3000};

U8 KeyCode = E_KC_NOKEY;        // key code
U8 KeyStatus = 0; 
U8 bKey;
U8 LstKS = 0;
U8 CurKS = 0;
U8 LstKStatus = 0; 
U16 KeyKeepTL = 0;
U8 KeyChangeTL = 0;
U8 byWaitTm = 0;

U16 wdWaitPCTimeLen = 3000;  /* 开始运行后的30秒等待与PC连接，过时不侯 */
BOOL bConnectWithPC = FALSE;

U32 dwdTm = 0;
U16 wdT1;
U16 wdT2;
U16 wdT3;
U16 wdT4;
U16 wdT5;
U16 wdT6;

ConfigData_t stSelConfigData;


const U16 cawdAD2CelTab[158] =
{
    /* -30 ~ 127 */
    3726,3702,3677,3651,3623,3596,3566,3536,3505,3472,
    3439,3405,3369,3333,3296,3258,3219,3180,3140,3098,
    3056,3012,2966,2919,2872,2823,2774,2724,2673,2622,
    2570,2519,2468,2416,2365,2313,2262,2211,2159,2108,
    2057,2007,1957,1908,1859,1810,1762,1715,1669,1623,
    1578,1534,1490,1448,1406,1365,1324,1285,1246,1208,
    1171,1136,1101,1067,1033,1001,970,940,910,881,
    854,827,801,776,752,728,706,684,662,641,
    621,602,583,565,547,530,514,498,482,467,
    452,438,425,412,399,386,375,363,352,341,
    331,321,311,301,292,283,275,267,259,251,
    243,236,229,222,216,210,204,198,192,186,
    181,176,171,166,161,156,152,148,143,139,
    135,132,128,125,121,118,115,112,109,107,
    104,101,99,96,94,91,89,87,85,83,
    81,79,77,75,74,72,70,68
};

#if 0
const WORD testUData[1000] = 
{
    29999,29691,29387,29085,28787,28492,28200,27910,27624,27341,
    27060,26783,26508,26236,25967,25701,25437,25176,24918,24663,
    24410,24159,23911,23666,23424,23183,22945,22710,22477,22247,
    22019,21793,21569,21348,21129,20912,20698,20486,20275,20067,
    19862,19658,19456,19257,19059,18864,18670,18479,18289,18102,
    17916,17732,17550,17370,17192,17016,16841,16669,16498,16328,
    16161,15995,15831,15669,15508,15349,15192,15036,14882,14729,
    14578,14428,14280,14134,13989,13845,13703,13563,13424,13286,
    13150,13015,12881,12749,12619,12489,12361,12234,12109,11985,
    11862,11740,11620,11500,11382,11266,11150,11036,10923,10811,
    10700,10590,10481,10374,10267,10162,10058,9955,9853,9751,
    9651,9552,9454,9358,9262,9167,9073,8979,8887,8796,
    8706,8617,8528,8441,8354,8269,8184,8100,8017,7934,
    7853,7773,7693,7614,7536,7459,7382,7306,7231,7157,
    7084,7011,6939,6868,6798,6728,6659,6591,6523,6456,
    6390,6324,6259,6195,6132,6069,6006,5945,5884,5824,
    5764,5705,5646,5588,5531,5474,5418,5362,5307,5253,
    5199,5146,5093,5041,4989,4938,4887,4837,4787,4738,
    4690,4642,4594,4547,4500,4454,4408,4363,4318,4274,
    4230,4187,4144,4101,4059,4018,3976,3936,3895,3855,
    3816,3777,3738,3700,3662,3624,3587,3550,3514,3478,
    3442,3407,3372,3337,3303,3269,3235,3202,3169,3137,
    3105,3073,3041,3010,2979,2949,2918,2888,2859,2829,
    2800,2772,2743,2715,2687,2660,2632,2605,2579,2552,
    2526,2500,2474,2449,2424,2399,2374,2350,2326,2302,
    2279,2255,2232,2209,2186,2164,2142,2120,2098,2077,
    2055,2034,2013,1993,1972,1952,1932,1912,1892,1873,
    1854,1835,1816,1797,1779,1761,1743,1725,1707,1689,
    1672,1655,1638,1621,1605,1588,1572,1556,1540,1524,
    1508,1493,1477,1462,1447,1432,1418,1403,1389,1375,
    1360,1346,1333,1319,1305,1292,1279,1266,1253,1240,
    1227,1214,1202,1190,1177,1165,1153,1142,1130,1118,
    1107,1095,1084,1073,1062,1051,1040,1030,1019,1009,
     998, 988, 978, 968, 958, 948, 938, 929, 919, 910,
     900, 891, 882, 873, 864, 855, 846, 838, 829, 820,
     812, 804, 795, 787, 779, 771, 763, 755, 748, 740,
     732, 725, 717, 710, 703, 696, 688, 681, 674, 667,
     661, 654, 647, 640, 634, 627, 621, 615, 608, 602,
     596, 590, 584, 578, 572, 566, 560, 554, 549, 543,
     537, 532, 526, 521, 516, 510, 505, 500, 495, 490,
     485, 480, 475, 470, 465, 460, 455, 451, 446, 442,
     437, 433, 428, 424, 419, 415, 411, 407, 402, 398,
     394, 390, 386, 382, 378, 374, 370, 367, 363, 359,
     355, 352, 348, 345, 341, 338, 334, 331, 327, 324,
     321, 317, 314, 311, 308, 304, 301, 298, 295, 292,
     289, 286, 283, 280, 277, 274, 272, 269, 266, 263,
     261, 258, 255, 253, 250, 247, 245, 242, 240, 237,
     235, 233, 230, 228, 225, 223, 221, 219, 216, 214,
     212, 210, 208, 205, 203, 201, 199, 197, 195, 193,
     191, 189, 187, 185, 183, 181, 179, 178, 176, 174,
     172, 170, 169, 167, 165, 164, 162, 160, 158, 157,
     155, 154, 152, 150, 149, 147, 146, 144, 143, 141,
     140, 138, 137, 136, 134, 133, 131, 130, 129, 127,
     126, 125, 124, 122, 121, 120, 119, 117, 116, 115,
     114, 113, 111, 110, 109, 108, 107, 106, 105, 104,
     102, 101, 100,  99,  98,  97,  96,  95,  94,  93,
      92,  91,  90,  89,  89,  88,  87,  86,  85,  84,
      83,  82,  81,  81,  80,  79,  78,  77,  77,  76,
      75,  74,  73,  73,  72,  71,  70,  70,  69,  68,
      67,  67,  66,  65,  65,  64,  63,  63,  62,  61,
      61,  60,  60,  59,  58,  58,  57,  56,  56,  55,
      55,  54,  54,  53,  52,  52,  51,  51,  50,  50,
      49,  49,  48,  48,  47,  47,  46,  46,  45,  45,
      44,  44,  43,  43,  43,  42,  42,  41,  41,  40,
      40,  39,  39,  39,  38,  38,  37,  37,  37,  36,
      36,  36,  35,  35,  34,  34,  34,  33,  33,  33,
      32,  32,  32,  31,  31,  31,  30,  30,  30,  29,
      29,  29,  28,  28,  28,  28,  27,  27,  27,  26,
      26,  26,  26,  25,  25,  25,  24,  24,  24,  24,
      23,  23,  23,  23,  22,  22,  22,  22,  21,  21,
      21,  21,  21,  20,  20,  20,  20,  20,  19,  19,
      19,  19,  18,  18,  18,  18,  18,  17,  17,  17,
      17,  17,  17,  16,  16,  16,  16,  16,  16,  15,
      15,  15,  15,  15,  15,  14,  14,  14,  14,  14,
      14,  13,  13,  13,  13,  13,  13,  13,  12,  12,
      12,  12,  12,  12,  12,  11,  11,  11,  11,  11,
      11,  11,  11,  11,  10,  10,  10,  10,  10,  10,
      10,  10,   9,   9,   9,   9,   9,   9,   9,   9,
       9,   9,   8,   8,   8,   8,   8,   8,   8,   8,
       8,   8,   8,   7,   7,   7,   7,   7,   7,   7,
       7,   7,   7,   7,   7,   6,   6,   6,   6,   6,
       6,   6,   6,   6,   6,   6,   6,   6,   6,   5,
       5,   5,   5,   5,   5,   5,   5,   5,   5,   5,
       5,   5,   5,   5,   5,   4,   4,   4,   4,   4,
       4,   4,   4,   4,   4,   4,   4,   4,   4,   4,
       4,   4,   4,   4,   4,   3,   3,   3,   3,   3,
       3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
       3,   3,   3,   3,   3,   3,   3,   3,   3,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
       2,   2,   1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
       1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
       1,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
       0,   0,   0,   0,   0,   0,   0,   0,   0,   0,

};

const WORD testIData[1000] = 
{
       1, 309, 613, 915,1213,1508,1800,2090,2376,2659,
    2940,3217,3492,3764,4033,4299,4563,4824,5082,5337,
    5590,5841,6089,6334,6576,6817,7055,7290,7523,7753,
    7981,8207,8431,8652,8871,9088,9302,9514,9725,9933,
    10138,10342,10544,10743,10941,11136,11330,11521,11711,11898,
    12084,12268,12450,12630,12808,12984,13159,13331,13502,13672,
    13839,14005,14169,14331,14492,14651,14808,14964,15118,15271,
    15422,15572,15720,15866,16011,16155,16297,16437,16576,16714,
    16850,16985,17119,17251,17381,17511,17639,17766,17891,18015,
    18138,18260,18380,18500,18618,18734,18850,18964,19077,19189,
    19300,19410,19519,19626,19733,19838,19942,20045,20147,20249,
    20349,20448,20546,20642,20738,20833,20927,21021,21113,21204,
    21294,21383,21472,21559,21646,21731,21816,21900,21983,22066,
    22147,22227,22307,22386,22464,22541,22618,22694,22769,22843,
    22916,22989,23061,23132,23202,23272,23341,23409,23477,23544,
    23610,23676,23741,23805,23868,23931,23994,24055,24116,24176,
    24236,24295,24354,24412,24469,24526,24582,24638,24693,24747,
    24801,24854,24907,24959,25011,25062,25113,25163,25213,25262,
    25310,25358,25406,25453,25500,25546,25592,25637,25682,25726,
    25770,25813,25856,25899,25941,25982,26024,26064,26105,26145,
    26184,26223,26262,26300,26338,26376,26413,26450,26486,26522,
    26558,26593,26628,26663,26697,26731,26765,26798,26831,26863,
    26895,26927,26959,26990,27021,27051,27082,27112,27141,27171,
    27200,27228,27257,27285,27313,27340,27368,27395,27421,27448,
    27474,27500,27526,27551,27576,27601,27626,27650,27674,27698,
    27721,27745,27768,27791,27814,27836,27858,27880,27902,27923,
    27945,27966,27987,28007,28028,28048,28068,28088,28108,28127,
    28146,28165,28184,28203,28221,28239,28257,28275,28293,28311,
    28328,28345,28362,28379,28395,28412,28428,28444,28460,28476,
    28492,28507,28523,28538,28553,28568,28582,28597,28611,28625,
    28640,28654,28667,28681,28695,28708,28721,28734,28747,28760,
    28773,28786,28798,28810,28823,28835,28847,28858,28870,28882,
    28893,28905,28916,28927,28938,28949,28960,28970,28981,28991,
    29002,29012,29022,29032,29042,29052,29062,29071,29081,29090,
    29100,29109,29118,29127,29136,29145,29154,29162,29171,29180,
    29188,29196,29205,29213,29221,29229,29237,29245,29252,29260,
    29268,29275,29283,29290,29297,29304,29312,29319,29326,29333,
    29339,29346,29353,29360,29366,29373,29379,29385,29392,29398,
    29404,29410,29416,29422,29428,29434,29440,29446,29451,29457,
    29463,29468,29474,29479,29484,29490,29495,29500,29505,29510,
    29515,29520,29525,29530,29535,29540,29545,29549,29554,29558,
    29563,29567,29572,29576,29581,29585,29589,29593,29598,29602,
    29606,29610,29614,29618,29622,29626,29630,29633,29637,29641,
    29645,29648,29652,29655,29659,29662,29666,29669,29673,29676,
    29679,29683,29686,29689,29692,29696,29699,29702,29705,29708,
    29711,29714,29717,29720,29723,29726,29728,29731,29734,29737,
    29739,29742,29745,29747,29750,29753,29755,29758,29760,29763,
    29765,29767,29770,29772,29775,29777,29779,29781,29784,29786,
    29788,29790,29792,29795,29797,29799,29801,29803,29805,29807,
    29809,29811,29813,29815,29817,29819,29821,29822,29824,29826,
    29828,29830,29831,29833,29835,29836,29838,29840,29842,29843,
    29845,29846,29848,29850,29851,29853,29854,29856,29857,29859,
    29860,29862,29863,29864,29866,29867,29869,29870,29871,29873,
    29874,29875,29876,29878,29879,29880,29881,29883,29884,29885,
    29886,29887,29889,29890,29891,29892,29893,29894,29895,29896,
    29898,29899,29900,29901,29902,29903,29904,29905,29906,29907,
    29908,29909,29910,29911,29911,29912,29913,29914,29915,29916,
    29917,29918,29919,29919,29920,29921,29922,29923,29923,29924,
    29925,29926,29927,29927,29928,29929,29930,29930,29931,29932,
    29933,29933,29934,29935,29935,29936,29937,29937,29938,29939,
    29939,29940,29940,29941,29942,29942,29943,29944,29944,29945,
    29945,29946,29946,29947,29948,29948,29949,29949,29950,29950,
    29951,29951,29952,29952,29953,29953,29954,29954,29955,29955,
    29956,29956,29957,29957,29957,29958,29958,29959,29959,29960,
    29960,29961,29961,29961,29962,29962,29963,29963,29963,29964,
    29964,29964,29965,29965,29966,29966,29966,29967,29967,29967,
    29968,29968,29968,29969,29969,29969,29970,29970,29970,29971,
    29971,29971,29972,29972,29972,29972,29973,29973,29973,29974,
    29974,29974,29974,29975,29975,29975,29976,29976,29976,29976,
    29977,29977,29977,29977,29978,29978,29978,29978,29979,29979,
    29979,29979,29979,29980,29980,29980,29980,29980,29981,29981,
    29981,29981,29982,29982,29982,29982,29982,29983,29983,29983,
    29983,29983,29983,29984,29984,29984,29984,29984,29984,29985,
    29985,29985,29985,29985,29985,29986,29986,29986,29986,29986,
    29986,29987,29987,29987,29987,29987,29987,29987,29988,29988,
    29988,29988,29988,29988,29988,29989,29989,29989,29989,29989,
    29989,29989,29989,29989,29990,29990,29990,29990,29990,29990,
    29990,29990,29991,29991,29991,29991,29991,29991,29991,29991,
    29991,29991,29992,29992,29992,29992,29992,29992,29992,29992,
    29992,29992,29992,29993,29993,29993,29993,29993,29993,29993,
    29993,29993,29993,29993,29993,29994,29994,29994,29994,29994,
    29994,29994,29994,29994,29994,29994,29994,29994,29994,29995,
    29995,29995,29995,29995,29995,29995,29995,29995,29995,29995,
    29995,29995,29995,29995,29995,29996,29996,29996,29996,29996,
    29996,29996,29996,29996,29996,29996,29996,29996,29996,29996,
    29996,29996,29996,29996,29996,29997,29997,29997,29997,29997,
    29997,29997,29997,29997,29997,29997,29997,29997,29997,29997,
    29997,29997,29997,29997,29997,29997,29997,29997,29997,29998,
    29998,29998,29998,29998,29998,29998,29998,29998,29998,29998,
    29998,29998,29998,29998,29998,29998,29998,29998,29998,29998,
    29998,29998,29998,29998,29998,29998,29998,29998,29998,29998,
    29998,29998,29999,29999,29999,29999,29999,29999,29999,29999,
    29999,29999,29999,29999,29999,29999,29999,29999,29999,29999,
    29999,29999,29999,29999,29999,29999,29999,29999,29999,29999,
    29999,29999,29999,29999,29999,29999,29999,29999,29999,29999,
    29999,29999,29999,29999,29999,29999,29999,29999,29999,29999,
    29999,30000,30000,30000,30000,30000,30000,30000,30000,30000,
    30000,30000,30000,30000,30000,30000,30000,30000,30000,30000,
    30000,30000,30000,30000,30000,30000,30000,30000,30000,30000,
    30000,30000,30000,30000,30000,30000,30000,30000,30000,30000,

};

#else
const WORD testIData[1000] = 
{

3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
3000,2966,2932,2898,2865,2832,2800,2768,2736,2705,
2674,2643,2613,2583,2553,2524,2495,2467,2438,2411,
2383,2356,2329,2302,2276,2250,2224,2198,2173,2148,
2124,2100,2075,2052,2028,2005,1982,1959,1937,1915,
1893,1871,1850,1829,1808,1787,1767,1746,1726,1707,
1687,1668,1649,1630,1611,1593,1574,1556,1539,1521,
1504,1486,1469,1453,1436,1419,1403,1387,1371,1356,
1340,1325,1310,1295,1280,1265,1251,1236,1222,1208,
1194,1181,1167,1154,1141,1128,1115,1102,1089,1077,
1064,1052,1040,1028,1017,1005, 993, 982, 971, 960,
 949, 938, 927, 916, 906, 896, 885, 875, 865, 855,
 846, 836, 826, 817, 807, 798, 789, 780, 771, 762,
 754, 745, 736, 728, 720, 711, 703, 695, 687, 679,
 672, 664, 656, 649, 641, 634, 627, 620, 613, 606,
 599, 592, 585, 578, 572, 565, 559, 552, 546, 540,
 533, 527, 521, 515, 509, 504, 498, 492, 487, 481,
 475, 470, 465, 459, 454, 449, 444, 439, 434, 429,
 424, 419, 414, 409, 405, 400, 395, 391, 386, 382,
 378, 373, 369, 365, 361, 357, 352, 348, 344, 341,
 337, 333, 329, 325, 321, 318, 314, 311, 307, 303,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 300, 300, 300, 300, 300, 300, 300, 300, 300,
 300, 292, 283, 275, 268, 260, 253, 246, 239, 232,
 226, 219, 213, 207, 201, 196, 190, 185, 180, 174,
 170, 165, 160, 156, 151, 147, 143, 139, 135, 131,
 128, 124, 120, 117, 114, 111, 107, 104, 102,  99,
  96,  93,  91,  88,  86,  83,  81,  79,  76,  74,
  72,  70,  68,  66,  64,  63,  61,  59,  57,  56,
  54,  53,  51,  50,  48,  47,  46,  44,  43,  42,
  41,  40,  38,  37,  36,  35,  34,  33,  32,  32,
  31,  30,  29,  28,  27,  27,  26,  25,  24,  24,
  23,  22,  22,  21,  21,  20,  19,  19,  18,  18,
  17,  17,  16,  16,  15,  15,  15,  14,  14,  13,
  13,  13,  12,  12,  12,  11,  11,  11,  10,  10,
  10,  10,   9,   9,   9,   8,   8,   8,   8,   8,
   7,   7,   7,   7,   7,   6,   6,   6,   6,   6,
   6,   5,   5,   5,   5,   5,   5,   5,   4,   4,
   4,   4,   4,   4,   4,   4,   4,   3,   3,   3,
   3,   3,   3,   3,   3,   3,   3,   3,   2,   2,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   2,
   2,   2,   2,   2,   2,   2,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,

};

const WORD testUData[1000] = 
{
    #if 0
      30,  64,  98, 132, 165, 198, 230, 262, 294, 325,
     356, 387, 417, 447, 477, 506, 535, 563, 592, 619,
     647, 674, 701, 728, 754, 780, 806, 832, 857, 882,
    #else
     906, 930, 955, 978,1002,1025,1048,1071,1093,1115,
    1137,1159,1180,1201,1222,1243,1263,1284,1304,1323,
    1343,1362,1381,1400,1419,1437,1456,1474,1491,1509,
    #endif
     906, 930, 955, 978,1002,1025,1048,1071,1093,1115,
    1137,1159,1180,1201,1222,1243,1263,1284,1304,1323,
    1343,1362,1381,1400,1419,1437,1456,1474,1491,1509,
    1526,1544,1561,1577,1594,1611,1627,1643,1659,1674,
    1690,1705,1720,1735,1750,1765,1779,1794,1808,1822,
    1836,1849,1863,1876,1889,1902,1915,1928,1941,1953,
    1966,1978,1990,2002,2013,2025,2037,2048,2059,2070,
    2081,2092,2103,2114,2124,2134,2145,2155,2165,2175,
    2184,2194,2204,2213,2223,2232,2241,2250,2259,2268,
    2276,2285,2294,2302,2310,2319,2327,2335,2343,2351,
    2358,2366,2374,2381,2389,2396,2403,2410,2417,2424,
    2431,2438,2445,2452,2458,2465,2471,2478,2484,2490,
    2497,2503,2509,2515,2521,2526,2532,2538,2543,2549,
    2555,2560,2565,2571,2576,2581,2586,2591,2596,2601,
    2606,2611,2616,2621,2625,2630,2635,2639,2644,2648,
    2652,2657,2661,2665,2669,2673,2678,2682,2686,2689,
    2693,2697,2701,2705,2709,2712,2716,2719,2723,2727,
    2730,2733,2737,2740,2744,2747,2750,2753,2756,2760,
    2763,2766,2769,2772,2775,2778,2780,2783,2786,2789,
    2792,2794,2797,2800,2802,2805,2808,2810,2813,2815,
    2818,2820,2822,2825,2827,2829,2832,2834,2836,2839,
    2841,2843,2845,2847,2849,2851,2853,2855,2857,2859,
    2861,2863,2865,2867,2869,2871,2873,2874,2876,2878,
    2880,2881,2883,2885,2886,2888,2890,2891,2893,2894,
    2896,2898,2899,2901,2902,2903,2905,2906,2908,2909,
    2911,2912,2913,2915,2916,2917,2919,2920,2921,2922,
    2924,2925,2926,2927,2928,2930,2931,2932,2933,2934,
    2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,
    2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,
    2955,2956,2956,2957,2958,2959,2960,2960,2961,2962,
    2963,2964,2964,2965,2966,2967,2967,2968,2969,2969,
    2970,2971,2972,2972,2973,2973,2974,2975,2975,2976,
    2977,2977,2978,2978,2979,2980,2980,2981,2981,2982,
    2982,2983,2984,2984,2985,2985,2986,2986,2987,2987,
    2988,2988,2989,2989,2990,2990,2990,2991,2991,2992,
    2992,2993,2993,2994,2994,2994,2995,2995,2996,2996,
    2996,2997,2997,2997,2998,2998,2999,2999,2999,3000,
    3000,3000,3001,3001,3001,3002,3002,3002,3003,3003,
    3003,3004,3004,3004,3004,3005,3005,3005,3006,3006,
    3006,3006,3007,3007,3007,3008,3008,3008,3008,3009,
    3009,3009,3009,3009,3010,3010,3010,3010,3011,3011,
    3011,3011,3012,3012,3012,3012,3012,3013,3013,3013,
    3013,3013,3014,3014,3014,3014,3014,3014,3015,3015,
    3015,3015,3015,3015,3016,3016,3016,3016,3016,3016,
    3017,3017,3017,3017,3017,3017,3017,3018,3018,3018,
    3018,3018,3018,3018,3019,3019,3019,3019,3019,3019,
    3019,3019,3020,3020,3020,3020,3020,3020,3020,3020,
    3000,3012,3024,3036,3047,3058,3069,3080,3090,3100,
    3110,3120,3129,3138,3147,3156,3164,3172,3180,3188,
    3196,3203,3211,3218,3225,3231,3238,3244,3251,3257,
    3263,3269,3274,3280,3285,3291,3296,3301,3306,3310,
    3315,3320,3324,3328,3333,3337,3341,3345,3348,3352,
    3356,3359,3363,3366,3369,3373,3376,3379,3382,3385,
    3387,3390,3393,3396,3398,3401,3403,3405,3408,3410,
    3412,3414,3417,3419,3421,3423,3424,3426,3428,3430,
    3432,3433,3435,3436,3438,3440,3441,3442,3444,3445,
    3447,3448,3449,3450,3452,3453,3454,3455,3456,3457,
    3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,
    3468,3468,3469,3470,3471,3471,3472,3473,3473,3474,
    3475,3475,3476,3476,3477,3478,3478,3479,3479,3480,
    3480,3481,3481,3482,3482,3483,3483,3483,3484,3484,
    3485,3485,3485,3486,3486,3486,3487,3487,3487,3488,
    3488,3488,3489,3489,3489,3489,3490,3490,3490,3490,
    3491,3491,3491,3491,3492,3492,3492,3492,3492,3493,
    3493,3493,3493,3493,3493,3494,3494,3494,3494,3494,
    3494,3494,3495,3495,3495,3495,3495,3495,3495,3495,
    3496,3496,3496,3496,3496,3496,3496,3496,3496,3496,
    3497,3497,3497,3497,3497,3497,3497,3497,3497,3497,
    3497,3497,3497,3497,3498,3498,3498,3498,3498,3498,
    3498,3498,3498,3498,3498,3498,3498,3498,3498,3498,
    3498,3498,3498,3498,3499,3499,3499,3499,3499,3499,
    3499,3499,3499,3499,3499,3499,3499,3499,3499,3499,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,
    3000,3000,3000,3000,3000,3000,3000,3000,3000,3000,

};

#endif


/*datas & funcitons define area -------------------------------*/

/*Functions ---------------------------------------------------*/
/****************************************************************
* Function:     Ctrl_IOInit
* Description:  控制相关IO初始化
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl_IOInit(void)
{
    GPIO_InitTypeDef  GPIO_InitStructure;
    //CD_INIT();
    //RES_INIT();
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    
     /*!< Configure PC.08, PC.09, PC.10, PC.11, PC.12 pin: D0, D1, D2, D3, CLK pin */
     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
     GPIO_Init(GPIOA, &GPIO_InitStructure);

     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5|GPIO_Pin_9|GPIO_Pin_10;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     GPIO_Init(GPIOA, &GPIO_InitStructure);

     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_8;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     GPIO_Init(GPIOA, &GPIO_InitStructure);

     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
     GPIO_Init(GPIOB, &GPIO_InitStructure);

     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
     GPIO_Init(GPIOB, &GPIO_InitStructure);


     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12|GPIO_Pin_15;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     GPIO_Init(GPIOB, &GPIO_InitStructure);

     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8|GPIO_Pin_9;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
     GPIO_Init(GPIOB, &GPIO_InitStructure);
     

     RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3\
         | GPIO_Pin_4 | GPIO_Pin_5;
     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
     GPIO_Init(GPIOC, &GPIO_InitStructure);
     
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    GPIO_Init(GPIOC, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
    GPIO_Init(GPIOC, &GPIO_InitStructure);
    return;
}

/****************************************************************
* Function:     Ctrl_ADCInit
* Description:  ADC 初始化
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl_ADCInit(void)
{
    ADC_InitTypeDef InitStructure;

    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);
    RCC_ADCCLKConfig(RCC_PCLK2_Div8);
    InitStructure.ADC_ContinuousConvMode = DISABLE;
    InitStructure.ADC_ScanConvMode = DISABLE;
    InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    InitStructure.ADC_Mode = ADC_Mode_Independent;
    InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    InitStructure.ADC_NbrOfChannel = 0;
    ADC_Init(ADC1,&InitStructure);

    /* Enable ADCx */
    ADC_Cmd(ADC1, ENABLE);

    /* Enable ADCx reset calibaration register */    
    ADC_ResetCalibration(ADC1);
    /* Check the end of ADCx reset calibration register */
    while(ADC_GetResetCalibrationStatus(ADC1));

    /* Start ADCx calibaration */
    ADC_StartCalibration(ADC1);
    /* Check the end of ADCx calibration */
    while(ADC_GetCalibrationStatus(ADC1));
    
}

/****************************************************************
* Function:     Ctrl_PwmInit
* Description:  PWM初始化
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl_PwmInit(void)
{
    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitdata;    //基本参数
    TIM_OCInitTypeDef TIM_OCInitStructure;   //PWM输出,
    
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,ENABLE);  //开启tim4的clk,
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4,ENABLE);  //通过对应位设置使Tim4寄存器复位,
    RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4,DISABLE);    //退出复位, 

    TIM_TimeBaseInitdata.TIM_Prescaler = 0x0;    //设置tim的预分频系数=0,72M全频,
    TIM_TimeBaseInitdata.TIM_ClockDivision = TIM_CKD_DIV1;   //设置tim的时钟分频因子,Tdts=n*Tck_int,
    TIM_TimeBaseInitdata.TIM_CounterMode = TIM_CounterMode_Up;  //向上计数,
    TIM_TimeBaseInitdata.TIM_Period = PWM_VAL_MAX;   //设置tim的自动重载,13位分辨率约7.5K,
    TIM_TimeBaseInitdata.TIM_RepetitionCounter = 0x00;   //仅用于tim1&tim8,
    TIM_TimeBaseInit(TIM4,&TIM_TimeBaseInitdata);
    TIM_ARRPreloadConfig(TIM4,ENABLE);   //允许Tim2计数器的ARR自动重载缓冲,
    //----Tim4的CHx_PWM的初始化参数,-----------------------------------------------
    TIM_OCInitStructure.TIM_OCMode=TIM_OCMode_PWM1;  //设置OC1M[2:0]为pwm1输出模式,OC1REF="1"为有效,
    TIM_OCInitStructure.TIM_Pulse=0x1fff;    //设置占空比时间,值将自动写入CCR1,
    TIM_OCInitStructure.TIM_OCPolarity=TIM_OCPolarity_High;  //设置输出极性,CCER的CC1P位,实际1=OC1REF的有效电平,
    TIM_OCInitStructure.TIM_OutputState=TIM_OutputState_Enable;  //使能该通道输出,CCER的CC1E位,
    //----高级定时器才有的参数,----------------------------------------------------
    TIM_OCInitStructure.TIM_OCIdleState=TIM_OCIdleState_Reset;   //空闲/死区输出状态=0,Timx_CR2的OISx,只有Tim1/8有,
    TIM_OCInitStructure.TIM_OCNIdleState=TIM_OCNIdleState_Reset;     //空闲/死区输出状态=0,Timx_CR2的OISxN,只有Tim1/8有,
    TIM_OCInitStructure.TIM_OCNPolarity=TIM_OCNPolarity_High;    //设置互补端输出极性,CCER的CC1NP位,
    TIM_OCInitStructure.TIM_OutputNState=TIM_OutputNState_Disable;  //无互补端输出,CCER的CC1NE位,
    //----按照指定参数初始化TIM_OC1~4,
    TIM_OC3Init(TIM4,&TIM_OCInitStructure);  //按照指定参数初始化TIM_OC3,
    TIM_OC3FastConfig(TIM4,TIM_OCFast_Enable); //开启快速输出模式,3周期,
    TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable); //使能TIM2在CCR3上的预装载寄存器,CCMR2_OC3PE=1,
    TIM_OC4Init(TIM4,&TIM_OCInitStructure);  //按照指定参数初始化TIM_OC4,
    TIM_OC4FastConfig(TIM4,TIM_OCFast_Enable); //开启快速输出模式,3周期,
    TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable); //使能TIM2在CCR4上的预装载寄存器,CCMR2_OC4PE=1,
    //----定时器启动-----------------------
    TIM_ITConfig(TIM4,TIM_IT_Update,DISABLE); //关中断,
    TIM_ClearFlag(TIM4,TIM_FLAG_Update); //必须先清除配置时候产生的更新标志,
    TIM_Cmd(TIM4,ENABLE); //使能定时器,
}


/****************************************************************
* Function:     Ctrl_Init
* Description:  控制部分初始化
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl_Init(void)
{
    /* IO init */
    Ctrl_IOInit();
    /* ADC init */
    Ctrl_ADCInit();
    /* PWM init */
    Ctrl_PwmInit();
    
    return;
}

/****************************************************************
* Function:     GetADCVal
* Description:  获取对应通道AD值
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
WORD GetADCVal(U8 Chn)
{
    ADC_RegularChannelConfig(ADC1,Chn,1,ADC_SampleTime_1Cycles5);
    ADC_SoftwareStartConvCmd(ADC1,ENABLE);
    while(!ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC));
    
    return ADC_GetConversionValue(ADC1);
}

/****************************************************************
* Function:     GetTempCelVal
* Description:  根据AD值计算摄氏温度值
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
CHAR GetTempCelVal(U16 wdADVal)
{
    CHAR cCelVal;
    SHORT i;
    
    if (wdADVal >= cawdAD2CelTab[0])
    {
        cCelVal = -30;
    }
    else if (wdADVal <= cawdAD2CelTab[157])
    {
        cCelVal = 127;
    }
    else
    {
        for (i = 0; i<158; i++)
        {
            if (wdADVal >= cawdAD2CelTab[i])
            {
                cCelVal = i - 30;
                break;
            }
        }
        
    }
    
    return cCelVal;
}

/****************************************************************
* Function:     KeyScan
* Description:  按键扫描
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void KeyScan(void)
{
    U16 wdTmp;

    wdTmp = GetADCVal(ADC_CHN_KEY);
    
    if (wdTmp > 3596)
    {
        KeyStatus = 0x00;
    }
    else if (wdTmp > 2572)
    {
        KeyStatus = KEY_CODE_K1;
    }
    else if (wdTmp > 1566)
    {
        KeyStatus = KEY_CODE_K2;
    }
    else if (wdTmp > 542)
    {
        KeyStatus = KEY_CODE_K3;
    }
    else
    {
        KeyStatus = KEY_CODE_K4;
    }
    
}

/****************************************************************
* Function:     KeyFilt
* Description:  按键滤波
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
/* TODO: can remove if new API works */
void KeyFilt(void)
{
    static U8 bKeyProc = 0;
    
    CurKS = KeyStatus;

    if (!bPowerUp)
    {
        LstKS = CurKS;
        bKey = FALSE;
        KeyCode = E_KC_NOKEY;
        return;
    }

    if(CurKS != LstKS)
    {
        if (E_KC_NOKEY == LstKS)
        {
            bKey = TRUE;
            bKeyProc = FALSE;
        }
        else
        {
            bKey = FALSE;
        }
        KeyKeepTL = 0x0000;         
        
        LstKS = CurKS;      
    }
    else
    {
        if(KeyKeepTL < 0xff00)
        {
            KeyKeepTL ++; 
        }

    }
    
    KeyCode = E_KC_NOKEY; 
    if(CurKS == E_KC_NOKEY)
    {
        return; 
    }
    
    if (!bKey)
    {
        return;
    }
    
    if(KeyKeepTL == KEY_DOWN_LEN_120MS)
    {
        if (KEY_CODE_K1 == CurKS)
        {
            KeyCode = E_KC_UP;
            bKeyProc = TRUE;
        }
        else if (KEY_CODE_K2 == CurKS)
        {
            KeyCode = E_KC_DOWN;
            bKeyProc = TRUE;
        }
        else if (KEY_CODE_K3 == CurKS)
        {
            KeyCode = E_KC_BACK;
            bKeyProc = TRUE;
        }
        else if (KEY_CODE_K4 == CurKS)
        {
            KeyCode = E_KC_SURE;
            bKeyProc = TRUE;
        }
    }

}

/****************************************************************
* Function:     KeyProc
* Description:  按键处理
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void KeyProc(void)
{
    BOOL bTmp;
    BYTE byCnt;
    
    if (CTRL_STATE_CHARGE == byState)
    {
        byMID = MID_TOP;
        return;
    }
    
    if(KeyCode == E_KC_NOKEY)
    {
        return; 
    }

    if (MID_TOP == byMID)
    {
        if (E_KC_BACK == KeyCode)
        {
            byMID = MID_SET;
            wdML1Offset = MID_LVL1_CFG;
            wdML1OffsetSel = 0xffff;
            wdML1OffsetMax = 2;
        }
    }
    else if (MID_SET == byMID)
    {
        if (E_KC_BACK == KeyCode)
        {
            byMID = MID_TOP;
            
        }
        else if (E_KC_UP == KeyCode)
        {
            wdML1Offset++;
            if (wdML1Offset >= wdML1OffsetMax)
            {
                wdML1Offset = 0;
            }
        }
        else if (E_KC_DOWN == KeyCode)
        {
            if (wdML1Offset)
            {
                wdML1Offset--;
            }
            else
            {
                wdML1Offset = wdML1OffsetMax-1;
            }
        }
        else if (E_KC_SURE == KeyCode)
        {
            if (MID_LVL1_CFG == wdML1Offset)
            {
                byMID = MID_CFG_SEL;
                wdML2CfgOffsetMax = CONFIG_DATA_NUM;
                wdML2CfgOffset = wdCurCfgDataIndex;
                //iDispCurErr = DBLoadCfgEx(wdML2CfgOffset,&stChargeCfgData);
                
            }
            else if (MID_LVL1_CHG == wdML1Offset)
            {
                byMID = MID_SHOW_CHG_DATA;
                if (wdCurUITFileInex)
                {
                    wdML2ChgOffsetMax = wdCurUITFileInex - 1;
                }
                else
                {
                    wdML2ChgOffsetMax = 0;
                }
                wdML2ChgOffset = wdML2ChgOffsetMax;
                
                byWaitTm = 4;
            }
        }
        
    }
    else if (MID_CFG_SEL == byMID)
    {
        if (E_KC_BACK == KeyCode)
        {
            byMID = MID_SET;
            wdML1Offset = MID_LVL1_CFG;
            wdML1OffsetMax = 2;
        }
        else if (E_KC_UP == KeyCode)
        {
            byCnt = 0;
            do 
            {
                byCnt++;
                wdML2CfgOffset++;
                if (wdML2CfgOffset >= wdML2CfgOffsetMax)
                {
                    wdML2CfgOffset = 0;
                }
                DBCfgValidCheck(wdML2CfgOffset, &bTmp);
            } while ((!bTmp) && (byCnt < CONFIG_DATA_NUM));

            //iDispCurErr = DBLoadCfg(wdML2CfgOffset,&stSelConfigData);
            
        }
        else if (E_KC_DOWN == KeyCode)
        {
            byCnt = 0;
            do 
            {
                byCnt++;
                if (wdML2CfgOffset)
                {
                    wdML2CfgOffset--;
                }
                else
                {
                    wdML2CfgOffset = wdML2CfgOffsetMax-1;
                }
                DBCfgValidCheck(wdML2CfgOffset, &bTmp);
            } while ((!bTmp) && (byCnt < CONFIG_DATA_NUM));
            //iDispCurErr = DBLoadCfg(wdML2CfgOffset,&stSelConfigData);
            
        }
        else if (E_KC_SURE == KeyCode)
        {
            wdML2CfgOffsetSel = wdML2CfgOffset;
            iDispCurErr = DBLoadCfgEx(wdML2CfgOffset,&stChargeCfgData);
            if (!iDispCurErr)
            {
                wdCurCfgDataIndex = wdML2CfgOffset;
            }
            DBSaveCfgSet(wdCurCfgDataIndex);
        }
    }
    else if (MID_SHOW_CHG_DATA == byMID)
    {
        if (E_KC_BACK == KeyCode)
        {
            byMID = MID_SET;
            wdML1Offset = MID_LVL1_CHG;
            wdML1OffsetMax = 2;
        }
        else if (E_KC_UP == KeyCode)
        {
            byWaitTm = 4;
            dwdDispChgCapacity = 0xffffffff;
            dwdDispChgTmLen = 0xffffffff;
            wdML2ChgOffset++;
            if (wdML2ChgOffset > wdML2ChgOffsetMax)
            {
                wdML2ChgOffset = 0;
            }
        }
        else if (E_KC_DOWN == KeyCode)
        {
            byWaitTm = 4;
            dwdDispChgCapacity = 0xffffffff;
            dwdDispChgTmLen = 0xffffffff;
            if (wdML2ChgOffset)
            {
                wdML2ChgOffset--;
            }
            else
            {
                wdML2ChgOffset = wdML2ChgOffsetMax;
            }
        }
        else if (E_KC_SURE == KeyCode)
        {
            if (wdML2ChgOffsetMax)
            {
                wdML2ChgOffsetSel = wdML2ChgOffset;
            }
        }
    }
}

/****************************************************************
* Function:     GetInputState
* Description:  获取各输入量，有滤波处理
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void GetInputState(void)
{
    static U8 BtSPCnt = 0;
    static U8 BtSNCnt = 0;
    static U8 ACOffCnt = 0;
    static U8 ACLowCnt = 0;

    STATE_FILT(bBTP,BtSPCnt,GET_BT_S_P)
    STATE_FILT(bBTN,BtSNCnt,GET_BT_S_N)
    STATE_FILT(bACLow,ACLowCnt,GET_AC_LOW)
    STATE_FILT(bACOff,ACOffCnt,GET_AC_OFF)

    if (bTem1Hi)
    {
        if (cTemp1 < TEM1_LO)
        {
            bTem1Hi=0;
        }
    }
    else
    {
        if (cTemp1 > TEM1_HI)   
        {
            bTem1Hi=1;
        }
    }
}
    
/****************************************************************
* Function:     Ctrl_ADC
* Description:  ADC，有滤波处理
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl_ADC(void)
{
    int i;
    
    if (!bADC)
    {
        return;
    }

    if (byADCCnt > 3)
    {
        byADCCnt = 0;
        return;
    }

    for (i = 0; i < E_ADC_INDEX_MAX; i++)
    {
        awdADCValSample[i] = GetADCVal(abyADCChn[i]);
    }

    if (0 == byADCCnt)
    {
        byADCCnt = 1;

        for (i = 0; i < E_ADC_INDEX_MAX; i++)
        {
            awdADCMax[i] = awdADCValSample[i];
            awdADCMin[i] = awdADCValSample[i];
            adwdADCSum[i] = awdADCValSample[i];
        }
        return;
    }

    for (i = 0; i < E_ADC_INDEX_MAX; i++)
    {
        if (awdADCValSample[i] > awdADCMax[i])
        {
            awdADCMax[i] = awdADCValSample[i];
        }

        if (awdADCValSample[i] < awdADCMin[i])
        {
            awdADCMin[i] = awdADCValSample[i];
        }

        adwdADCSum[i] += awdADCValSample[i];
    }

    if (3 == byADCCnt)
    {
        for (i = 0; i < E_ADC_INDEX_MAX; i++)
        {
            awdADCVal[i] = (adwdADCSum[i] - awdADCMax[i] - awdADCMin[i])>>1;
        }
        bADC = FALSE;
        byADCCnt = 0;
        return;
    }
    
    
    byADCCnt++;

    
}
/****************************************************************
* Function:     
* Description:  
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void TimerRun(void)
{
    if(bTimerPu)
        {return;}
    dwdTm++; 
}

void ResetTimer(void)
{
    dwdTm = 0;
    bTimerPu = FALSE;
}

U32 GetTimer(void)
{
    
    return dwdTm;
}
    

/****************************************************************
* Function:     GetUISet
* Description:  获取UI设置情况，待根据实际情况初充
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void GetUISet(void)
{
    U16 wdADUSet;
    U16 wdADISet;

    wdADUSet = GetADCVal(ADC_CHN_V_SEL_TEST);
    wdADISet = GetADCVal(ADC_CHN_I_SET);

    /* 可根据AD值区间完成机型电压电流类型设定 */

    byVoltType = 1;
    byCurType = 4;
}

/****************************************************************
* Function:     GetCSet
* Description:  
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void GetCSet(void)
{
    U16 wdADCSet;
    
    wdADCSet = GetADCVal(ADC_CHN_C_SET);

    /* 可根据AD值区间完成机型电压电流类型设定 */

    byCSetType = 0;
}

/****************************************************************
* Function:     PowerOnProc
* Description:  上电时的处理过程
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void PowerOnProc(void)
{
#if 1
    ConfigData_t stCfgData;
    INT i;
    INT ret;
    WORD wdTmp;
    
#endif
    GetUISet();
    bFirst = TRUE;
    dwdChargeBeginTm = RTC_GetCounter();
    if (DBLoadCalibValue(&wdVoltCalib, &wdCurCalib))
    {
        wdVoltCalib = CALIB_DEFAULT_VOLT_VAL;
        wdCurCalib = CALIB_DEFAULT_CUR_VAL;
    }
    
#if 1   
    if (DBInit())
    {
        for (i = 0; i < 6 ; i++)
        {
            stCfgData.I1 = castChgCfgData[i].I1;
            stCfgData.I2 = castChgCfgData[i].I2;
            stCfgData.I3 = castChgCfgData[i].I3;
            stCfgData.i4 = castChgCfgData[i].i4;
            stCfgData.I5 = castChgCfgData[i].I5;
            stCfgData.I6 = castChgCfgData[i].I6;

            stCfgData.u0 = castChgCfgData[i].u0;
            stCfgData.u1 = castChgCfgData[i].u1;
            stCfgData.Ucv = castChgCfgData[i].Ucv;
            stCfgData.U5 = castChgCfgData[i].U5;
            stCfgData.U6 = castChgCfgData[i].U6;

            stCfgData.To = castChgCfgData[i].To;
            
            stCfgData.T1 = castChgCfgData[i].T1;
            stCfgData.T2 = castChgCfgData[i].T2;
            stCfgData.T3 = castChgCfgData[i].T3;
            stCfgData.T4 = castChgCfgData[i].T4;
            stCfgData.T5 = castChgCfgData[i].T5;
            stCfgData.T6 = castChgCfgData[i].T6;

            mem_cpy(stCfgData.acName, castChgCfgData[i].acName, CONFIG_NAME_LEN);

            stCfgData.bValid = CONFIG_DATA_VALID;
            stCfgData.ChkSum = GetChkSum((U8 *)(&stCfgData),SIZE_CONFIG_DATA - sizeof(stCfgData.ChkSum));

            ret = DBSaveCfg(i,&stCfgData);
            if (ret)
            {
                break;
            }
            else
            {
                if (5 == i)
                {
                    ret = DBSaveCfgSet(0);
                }
            }
            
        }
#endif      
        if (DBInit())
        {
            byState = CTRL_STATE_ERROR;
            wdTmp = byCurType + 1;
            stChargeCfgData.I1 = wdTmp*75;
            stChargeCfgData.I2 = wdTmp* 500;
            stChargeCfgData.I3 = wdTmp*0;
            stChargeCfgData.i4 = wdTmp*75;
            stChargeCfgData.I5 = wdTmp*75;
            stChargeCfgData.I6 = wdTmp*75;
 
            wdTmp = byVoltType + 1;
            stChargeCfgData.u0 = wdTmp*798;
            stChargeCfgData.u1 = wdTmp*1146;
            stChargeCfgData.Ucv = wdTmp*1440;
            stChargeCfgData.U5 = wdTmp*1560;
            stChargeCfgData.U6 = wdTmp*1380;

            stChargeCfgData.To = 720;
            stChargeCfgData.T1 = 120;
            stChargeCfgData.T2 = 540;
            stChargeCfgData.T3 = 0;
            stChargeCfgData.T4 = 420;
            stChargeCfgData.T5 = 0;
            stChargeCfgData.T6 = 60000;
            //byErr = ERROR_CFG;
            
            //ResetTimer();
            //return;
        }
#if 1
    }
#endif      
    //byState = CTRL_STATE_SELF_TEST;
    wdTmp = GetADCVal(ADC_CHN_V_SEL_TEST);
    if (wdTmp < 200)
    {
        byState = CTRL_STATE_TEST;
    }
    else
    {
        byState = CTRL_STATE_STAND_BY;
    }

    bPowerUp = TRUE;

    ResetTimer();
}


/****************************************************************
* Function:     PwmIOut
* Description:  控制电流的PWM输出
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void PwmIOut(U16 val)
{
    TIM_SetCompare3(TIM4, val);
}

/****************************************************************
* Function:     PwmUOut
* Description:  控制电压的PWM输出
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void PwmUOut(U16 val)
{
    TIM_SetCompare4(TIM4, val);
}

/****************************************************************
* Function:     LoadRefresh
* Description:  各输出的刷新操作
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void LoadRefresh(void)
{
    static U8 div = 0;

    

    if (bTurnOn)
    {
        switch (bySWCnt)
        {
            case 0:
                break;
            case 1:
                break;
            case 2:
                wdUPwmLast = wdUPwm;
                wdIPwmLast = wdIPwm;
                wdICurPwm = wdIPwm;
                break;
            case 4:
                bSWPowerONLast = bSWPowerON;
                bSWRyOutLast = bSWRyOut;
                break;
            case 6:
                bSWMosOnLast = bSWMosOn;
                break;
            case 7:
                bSWFanOnLast = bSWFanOn;
                break;
            case 8:
                bSWRyInhiLast = bSWRyInhi;
                break;
            default:
                //bySWCnt = 0;
                break;
        }
    }
    else if (bTurnOff)
    {
        switch (bySWCnt)
        {
            case 0:
                break;
            case 1:
                break;
            case 2:
                bSWPowerONLast = bSWPowerON;
                bSWMosOnLast = bSWMosOn;
                break;
            case 4:
                bSWRyOutLast = bSWRyOut;
                bSWRyInhiLast = bSWRyInhi;
                bSWFanOnLast = bSWFanOn;
                wdUPwmLast = wdUPwm;
                wdIPwmLast = wdIPwm;
                wdICurPwm = wdIPwm;
                break;
            default:
                //bySWCnt = 0;
                break;
        }
    }
    else
    {
        bSWPowerONLast = bSWPowerON;
        bSWMosOnLast = bSWMosOn;
        bSWRyOutLast = bSWRyOut;
        bSWRyInhiLast = bSWRyInhi;
        bSWFanOnLast = bSWFanOn;
        wdUPwmLast = wdUPwm;
        wdIPwmLast = wdIPwm;
    }
    
    bSWFanOnLast?SET_FAN_ON():SET_FAN_OFF();
    bSWMosOnLast?SET_MOS_ON():SET_MOS_OFF();
    bSWPowerONLast?SET_POWER_ON():SET_POWER_OFF();
    bSWRyInhiLast?SET_RY_INHI_ON():SET_RY_INHI_OFF();
    bSWRyOutLast?SET_RY_OUT_ON():SET_RY_OUT_OFF();
    bLEDR?STM_EVAL_LEDOn(LED1):STM_EVAL_LEDOff(LED1);
    bLEDY?STM_EVAL_LEDOn(LED2):STM_EVAL_LEDOff(LED2);
    bLEDG?STM_EVAL_LEDOn(LED3):STM_EVAL_LEDOff(LED3);

    div++;
    if (div < 10)
    {
        return;
    }
    div = 0;

    if (wdICurPwm < wdIPwmLast)
    {
        wdICurPwm += PWM_STEP_VAL;
        if (wdICurPwm > wdIPwmLast)
        {
            wdICurPwm = wdIPwmLast;
        }
    }
    else if (wdICurPwm > wdIPwmLast)
    {
        if (wdICurPwm >= PWM_STEP_VAL)
        {
            wdICurPwm -= PWM_STEP_VAL;
            
        }
        else
        {
            wdICurPwm = 0;
        }
        
        if (wdICurPwm < wdIPwmLast)
        {
            wdICurPwm = wdIPwmLast;
        }
    }

    PwmIOut(wdICurPwm);
    PwmUOut(wdUPwmLast);
    
    
}

/****************************************************************
* Function:     LEDDisp
* Description:  指示灯显示
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void LEDDisp(void)
{
    static U8 Div = 0;
    static U8 Cnt = 0;
    static BOOL bFlash1Hz = FALSE;
    static U8 FlsDiv = 0;

    FlsDiv++;
    if (FlsDiv >= 50)
    {
        FlsDiv = 0;
        bFlash1Hz = !bFlash1Hz;
    }
    
    bLEDR = FALSE;
    bLEDY = FALSE;
    bLEDG = FALSE;
    
    switch (byState)
    {
        case CTRL_STATE_IDLE:
            bLEDG = TRUE;
            break;
        case CTRL_STATE_STAND_BY:
            bLEDY = bFlash1Hz;
            break;
        case CTRL_STATE_SELF_TEST:
            break;
        case CTRL_STATE_TEST:
            Div ++;
            if (Div >= 50)
            {
                Div = 0;
                Cnt ++;
                if (Cnt >= 3)
                {
                    Cnt = 0;
                }
            }

            if (0 == Cnt)
            {
                bLEDR = TRUE;
            }
            else if (1 == Cnt)
            {
                bLEDY = TRUE;
            }
            else
            {
                bLEDG = TRUE;
            }
            
            break;
        case CTRL_STATE_CHARGE:
            switch (byChgStep)
            {
                case CHARGE_STEP_PREV:
                    bLEDY = TRUE;
                    break;
                case CHARGE_STEP_CC1:
                    bLEDY = TRUE;
                    break;
                case CHARGE_STEP_CC2:
                    bLEDY = TRUE;
                    break;
                case CHARGE_STEP_CV:
                    bLEDY = TRUE;
                    break;
                case CHARGE_STEP_ABSO:
                    bLEDY = TRUE;
                    bLEDG = TRUE;
                    break;
                case CHARGE_STEP_FLOAT:
                    bLEDG = TRUE;
                    break;
                default:
                    break;
            }
            break;
        case CTRL_STATE_ERROR:
            {
                switch (byErr)
                {
                    case ERROR_SELF_TEST:
                        bLEDR = bFlash1Hz;
                        bLEDY = bFlash1Hz;
                        bLEDG = bFlash1Hz;
                        break;
                    case ERROR_TEMP:
                        break;
                    case ERROR_BT_REV:
                        bLEDR = bFlash1Hz;
                        break;
                    case ERROR_BT_LOW:
                        bLEDR = TRUE;
                        break;
                    case ERROR_CFG:
                    case ERROR_SAVE_DATA:               
                    case ERROR_ERROR:
                        if (bFlash1Hz)
                        {
                            bLEDR = TRUE;
                        }
                        else
                        {
                            bLEDY = TRUE;
                        }
                        break;
                    
                }
            }
            break;
        default:
            break;
    }
}

/****************************************************************
* Function:     Ctrl
* Description:  控制过程
* Input:        
* Output:       
* Return:       
* Other:        
****************************************************************/
void Ctrl(void)
{
    U32 dwdTmp;
    U16 wdTmp1;
    U16 wdTmp2;
    static U8 Cnt = 0;
    UIT_t stUIT;
    static U8 byWait = 0;
#if DEBUG_CHARGE
    static U32 dwdDbgCnt = 0;
#endif

    

    if (byWaitTm)
    {
        byWaitTm--;

        if ((MID_SHOW_CHG_DATA == byMID) && (!byWaitTm))
        {
            DBGetCT(wdML2ChgOffset+1, &dwdDispChgCapacity, &dwdDispChgTmLen);
        }
    }

    //if (byWait < 2)
    //{
    //  byWait++; 
        //return;
    //}

    if (bTurnOn)
    {
        bySWCnt++;
        if (bySWCnt >= 8)
        {
            bySWCnt = 0;
            bTurnOn = FALSE;
        }
        
        
    }
    else if (bTurnOff)
    {
        bySWCnt++;
        if (bySWCnt >= 5)
        {
            bySWCnt = 0;
            bTurnOn = FALSE;
        }
    }


    

/* Test ..... */
    if (!bADC)
    {
        bGetVal = TRUE;
        bADC = TRUE;
        byADCCnt = 0;

        if (byVoltType >= VOLTAGE_TYPE_NUM)
        {
            byVoltType = 0;
        }
        
#if DEBUG_CHARGE

        dwdDbgCnt++;
        dwdDbgCnt = dwdDbgCnt%1000;
        wdBtVoltage = testUData[dwdDbgCnt];
        wdOutVoltage = testUData[dwdDbgCnt];
        wdCurrent = testIData[dwdDbgCnt];
#else
        dwdTmp = awdADCVal[E_ADC_INDEX_V_BAT];
        dwdTmp *= awdVoltTypeValue[byVoltType];
        dwdTmp /= wdVoltCalib;
        wdBtVoltage = dwdTmp;
        
        dwdTmp = awdADCVal[E_ADC_INDEX_V_OUT];
        dwdTmp *= awdVoltTypeValue[byVoltType];
        dwdTmp /= wdVoltCalib;
        wdOutVoltage = dwdTmp;

        dwdTmp = awdADCVal[E_ADC_INDEX_CHR_I];
        dwdTmp *= awdCurTypeValue[byCurType];
        dwdTmp /= wdCurCalib;
        wdCurrent = dwdTmp;
#endif
        cTemp1 = GetTempCelVal(awdADCVal[E_ADC_INDEX_VTM1]);
        cTemp2 = GetTempCelVal(awdADCVal[E_ADC_INDEX_VTM2]);

        
    }

    bSWFanOn = FALSE;
    bSWMosOn = FALSE;
    bSWPowerON = FALSE;
    bSWRyInhi = FALSE;
    bSWRyOut = FALSE;
    wdUPwm = 0;
    wdIPwm = 0;

    if (!bGetVal)
    {
        return;
    }

    /* if (bPowerUp)
    {
        byState = CTRL_STATE_POWER_ON;
        wdPwrCnt++;
        if (wdPwrCnt > 2)
        {
            bPowerUp = FALSE;
        }
    }*/
    

    switch (byState)
    {
        case CTRL_STATE_IDLE:
            bFirst = FALSE; 
            #if DEBUG_CHARGE
            bBTN = 0;
            bACLow = 0;
            bACOff = 0;
            #endif
            if (bBTN)
            {
                byState = CTRL_STATE_ERROR;
                byErr = ERROR_BT_REV;
                ResetTimer();
                bFirst = TRUE;
            }
            else if (bACLow || bACOff)
            {
                byState = CTRL_STATE_ERROR;
                byErr = ERROR_ERROR;
                ResetTimer();
                bFirst = TRUE;
            }
            break;
        case CTRL_STATE_STAND_BY:
            #if DEBUG_CHARGE
            bBTN = 0;
            bACLow = 0;
            bACOff = 0;
            bBTP = 1;
            #endif
            if ((!(bACLow || bACOff || bBTN)) && (!bBTP))
            {
                ResetTimer();
                bFirst = TRUE;
            }
            else if ((!(bACLow || bACOff || bBTN)) && bBTP)
            {
                if (GetTimer() >= 2)
                {
                    if (wdBtVoltage < awdVoltTypeValue[byVoltType]*2/3)
                    {
                        byState = CTRL_STATE_ERROR;
                        byErr = ERROR_BT_LOW;
                        ResetTimer();
                        bFirst = TRUE;
                    }
                    else if (!bChgDisable) /* 上位机根据情况,有时会禁止充电*/
                    {
                        byState = CTRL_STATE_CHARGE;
                        ResetTimer();
                        bFirst = TRUE;
                        wdCurUITFileInex++;
                        if (wdCurUITFileInex > CHARGE_DATA_NUM)
                        {
                            wdCurUITFileInex = 1;
                        }
                        if (wdUITFileNum < CHARGE_DATA_NUM)
                        {
                            wdUITFileNum++;
                        }
                        dwdUITFileTotalNum++;
                        dwdUITCnt = 0;
                        byChgStep = CHARGE_STEP_PREV;
                        bySaveUITCnt = 0;
                        GetUITFileName(wdCurUITFileInex, acUITDataPath);
                        dwdChargeBeginTm = RTC_GetCounter();
                        dwdCapacity = 0;
                        wdLastCurrent = 0;
                        bySWCnt = 0;
                        bTurnOff = FALSE;
                        bTurnOn = TRUE;
                        byJudgeWaitCnt = 0;
                    }
                }
                
            }
            else if (bBTN)
            {
                byState = CTRL_STATE_ERROR;
                byErr = ERROR_BT_REV;
                ResetTimer();
                bFirst = TRUE;
            }
            break;
        #if 0
        case CTRL_STATE_POWER_ON:
            if (1 == wdPwrCnt)
            {
                GetUISet();
            }
            else if (2 == wdPwrCnt)
            {
                bPowerUp = FALSE;
                if (DBLoadCfg())
                {
                    
                    byState = CTRL_STATE_ERROR;
                    byErr = ERROR_CFG;
                }
                else
                {
                    byState = CTRL_STATE_SELF_TEST;
                    ResetTimer();
                }
            }
            break;
        #endif
        case CTRL_STATE_SELF_TEST:
            
            // wdUPwm = stChargeCfgData.Ucv*(byVoltType+1)*PWM_VAL_MAX*3/awdVoltTypeValue[byVoltType]/4;
            dwdTmp = stChargeCfgData.Ucv;
            //dwdTmp *= (byVoltType+1);
            dwdTmp *= PWM_VAL_MAX*3;
            dwdTmp /= awdVoltTypeValue[byVoltType];
            wdUPwm = dwdTmp/4;

            wdIPwm = PWM_VAL_MAX+10;
            /* 自检时直接变化到需要的输出值 */
            wdICurPwm = wdIPwm;
            bSWPowerON = TRUE;
            
            if (bFirst)
            {
                bFirst = FALSE;
            }
            else
            {
                #if !DEBUG_CHARGE
                if ((wdOutVoltage < stChargeCfgData.Ucv*9/10) || (wdOutVoltage > stChargeCfgData.Ucv*11/10))
                {
                        byState = CTRL_STATE_ERROR;
                        byErr = ERROR_SELF_TEST;
                        ResetTimer();
                        bFirst = TRUE;
                }
                
                else
                #endif
                {
                    byState = CTRL_STATE_STAND_BY;
                    ResetTimer();
                    bFirst = TRUE;
                }
            }
            
            break;
        case CTRL_STATE_TEST:
            dwdTmp = stChargeCfgData.Ucv;
            dwdTmp *= PWM_VAL_MAX*3;
            dwdTmp /= awdVoltTypeValue[byVoltType];
            wdUPwm = dwdTmp/4;

            dwdTmp = stChargeCfgData.I2;
            dwdTmp *= PWM_VAL_MAX;
            wdIPwm = dwdTmp/awdCurTypeValue[byCurType];
            if (GetTimer() >= 3)
                {
                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;
                    bSWFanOn = TRUE;
                
}
                else if  (GetTimer() >= 1)
                {
                                                    
                    bSWRyOut = TRUE;
                    bSWMosOn = FALSE;
                    bSWPowerON = FALSE; 
                    bSWFanOn = FALSE;
                
}
                   
            break;
        case CTRL_STATE_CHARGE:
            dwdCapacity += (wdCurrent + wdLastCurrent) >> 1;
            wdLastCurrent = wdCurrent;
            bySaveUITCnt++;
            if (bySaveUITCnt >= SAVE_UIT_TM_SPACE)
            {
                bySaveUITCnt = 0;
                if (!dwdUITCnt)
                {
                    f_unlink(acUITDataPath);
                }
                stUIT.U = wdBtVoltage;
                stUIT.I = wdCurrent;
                stUIT.T1 = cTemp1;
                stUIT.T2 = cTemp2;
                stUIT.Step = byChgStep;
                DBSaveUITemp(&stUIT, dwdUITCnt);
                if (!dwdUITCnt)
                {
                    DBSaveUITSet(wdCurUITFileInex,wdUITFileNum,dwdUITFileTotalNum);
                }
                dwdUITCnt++;
            }
            
            
            
            switch (byChgStep)
            {
                case CHARGE_STEP_PREV:
                    bTimerPu = FALSE;
                    dwdTmp = stChargeCfgData.Ucv;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    dwdTmp = stChargeCfgData.I1;
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];
                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;

                    wdT1 = GetTimer()/60;
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else if (byJudgeWaitCnt > JUDGE_WAIT_TM)
                    {
                        #if DEBUG_CHARGE
                        if (!((dwdDbgCnt+1) % 500)) 
                        {
                            byChgStep = CHARGE_STEP_CC1;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                        #endif
                        
                        

                        if (wdBtVoltage >= stChargeCfgData.u1)
                        {
                            if (byVolFiltCnt < 0xf0)
                            {
                                byVolFiltCnt++;
                            }
                        }
                        else
                        {
                            byVolFiltCnt = 0;
                        }
    
                        if ((byVolFiltCnt >= VOLT_FILT_TM) || (wdT1 >= stChargeCfgData.T1))
                        {
                            byChgStep = CHARGE_STEP_CC1;
                            ResetTimer();
                            bFirst = TRUE;
                            byJudgeWaitCnt = 0;
                        }
                    }
                        
                    
                    break;
                case CHARGE_STEP_CC1:
                    dwdTmp = stChargeCfgData.Ucv;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    dwdTmp = stChargeCfgData.I2;
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];

                    if (bACLow || bTem1Hi)
                    {
                        wdIPwm = wdIPwm>>1;
                        bTimerPu = TRUE;
                    }
                    else
                    {
                        bTimerPu = FALSE;
                    }

                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;
                    bSWFanOn = TRUE;

                    wdT2 = GetTimer()/60;
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else if (byJudgeWaitCnt > JUDGE_WAIT_TM)
                    {
                        dwdTmp = stChargeCfgData.Ucv;
                        dwdTmp *= 96;
                        dwdTmp /= 100;
                        wdTmp1 = dwdTmp;

                        dwdTmp = stChargeCfgData.I2;
                        dwdTmp *= 85;
                        dwdTmp /= 100;
                        wdTmp2 = dwdTmp;
                        #if DEBUG_CHARGE
                        if (!((dwdDbgCnt+1) % 500)) 
                        {
                            byChgStep = CHARGE_STEP_CC2;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                        #endif

                        if (wdBtVoltage >= wdTmp1)
                        {
                            if (byVolFiltCnt < 0xf0)
                            {
                                byVolFiltCnt++;
                            }
                        }
                        else
                        {
                            byVolFiltCnt = 0;
                        }

                        if (wdCurrent <= wdTmp2)
                        {
                            if (byCurrFiltCnt < 0xf0)
                            {
                                byCurrFiltCnt++;
                            }
                        }
                        else
                        {
                            byCurrFiltCnt = 0;
                        }
                
                        
                        if (((byVolFiltCnt >= VOLT_FILT_TM) 
                            && (byCurrFiltCnt >= CURR_FILT_TM) )
                            || (wdT2 >= stChargeCfgData.T2))
                        {
                            byChgStep = CHARGE_STEP_CC2;
                            ResetTimer();
                            bFirst = TRUE;
                            byJudgeWaitCnt = 0;
                        }
                    }
                    
                    break;
                case CHARGE_STEP_CC2:
                    dwdTmp = stChargeCfgData.Ucv;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    //dwdTmp = stChargeCfgData.I3;
                    if (stChargeCfgData.I3)
                    {
                        dwdTmp = stChargeCfgData.I3;
                    }
                    else
                    {
                        dwdTmp = stChargeCfgData.I2;
                    }
                        
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];
                    if (bACLow || bTem1Hi)
                    {
                        wdIPwm = wdIPwm>>1;
                        bTimerPu = TRUE;
                    }
                    else
                    {
                        bTimerPu = FALSE;
                    }

                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;
                    bSWFanOn = TRUE;

                    wdT3 = GetTimer()/60;
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else if (byJudgeWaitCnt > JUDGE_WAIT_TM)
                    {
                        if (stChargeCfgData.I3)
                        {
                            dwdTmp = stChargeCfgData.I3;
                        }
                        else
                        {
                            dwdTmp = stChargeCfgData.I2;
                        }
                        dwdTmp *= 85;
                        dwdTmp /= 100;
                        wdTmp2 = dwdTmp;
                        #if DEBUG_CHARGE
                        if (!((dwdDbgCnt+1) % 500)) 
                        {
                            byChgStep = CHARGE_STEP_CV;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                        #endif

                        if (wdCurrent <= wdTmp2)
                        {
                            if (byCurrFiltCnt < 0xf0)
                            {
                                byCurrFiltCnt++;
                            }
                        }
                        else
                        {
                            byCurrFiltCnt = 0;
                        }
                        
                        
                        if ((byCurrFiltCnt >= CURR_FILT_TM)
                            || (wdT3 >= stChargeCfgData.T3))
                        {
                            byChgStep = CHARGE_STEP_CV;
                            ResetTimer();
                            bFirst = TRUE;
                            byJudgeWaitCnt = 0;
                        }
                        
                    }
                    
                    break;
                case CHARGE_STEP_CV:
                    dwdTmp = stChargeCfgData.Ucv;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    //dwdTmp = stChargeCfgData.I3;
                    if (stChargeCfgData.I3)
                    {
                        dwdTmp = stChargeCfgData.I3;
                    }
                    else
                    {
                        dwdTmp = stChargeCfgData.I2;
                    }
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];

                    if (bACLow || bTem1Hi)
                    {
                        wdIPwm = wdIPwm>>1;
                        bTimerPu = TRUE;
                    }
                    else
                    {
                        bTimerPu = FALSE;
                    }
                    

                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;

                    if (wdCurrent <= 3*awdCurTypeValue[byCurType]/10)
                    {
                        bSWFanOn = TRUE;
                    }

                    wdT4 = GetTimer()/60;
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else if (byJudgeWaitCnt > JUDGE_WAIT_TM)
                    {
                        #if DEBUG_CHARGE
                        if (!((dwdDbgCnt+1) % 500)) 
                        {
                            byChgStep = CHARGE_STEP_ABSO;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                        #endif

                        if (wdCurrent <= stChargeCfgData.i4)
                        {
                            if (byCurrFiltCnt < 0xf0)
                            {
                                byCurrFiltCnt++;
                            }
                        }
                        else
                        {
                            byCurrFiltCnt = 0;
                        }
                        
                        if ((byCurrFiltCnt >= CURR_FILT_TM)
                            || (wdT4 >= stChargeCfgData.T4)
                            || ((wdT2 + wdT3 + wdT4) >= stChargeCfgData.To))
                        {
                            byChgStep = CHARGE_STEP_ABSO;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                    }
                    
                    break;
                case CHARGE_STEP_ABSO:

                        dwdTmp = stChargeCfgData.U5;
                        //dwdTmp *= (byVoltType+1);
                        dwdTmp *= PWM_VAL_MAX*3;
                        dwdTmp /= awdVoltTypeValue[byVoltType];
                        wdUPwm = dwdTmp/4;
                                        
                    dwdTmp = stChargeCfgData.I5;
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];
                    
                    wdIPwmLast = wdIPwm;
                    wdICurPwm = wdIPwmLast;
                   // if (wdIPwm == wdICurPwm)
                    //{
                        
                    //}
                    
                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;
                    wdT5 = GetTimer()/60;

                    if (stChargeCfgData.T5)
                    {
                        wdTmp1 = wdT2 + wdT3 + wdT4;
                        if (wdTmp1 <= 60)
                        {
                            wdTmp2 = 60;
                        }
                        else if (wdTmp1 <= stChargeCfgData.T5)
                        {
                            /* 根据新沟通的需求更改 20151210 */
                            wdTmp2 = wdTmp1; //stChargeCfgData.To;
                        }
                        else
                        {
                            wdTmp2 = stChargeCfgData.T5;
                        }
                    }
                    else
                    {
                        wdTmp2 = 0;
                    }

                    bFirst = FALSE;

                    #if DEBUG_CHARGE
                    if (!((dwdDbgCnt+1) % 500)) 
                    {
                        byChgStep = CHARGE_STEP_FLOAT;
                        ResetTimer();
                        bFirst = TRUE;
                    }
                    #endif
                    
                    if (wdT5 >= wdTmp2)
                    {
                        byChgStep = CHARGE_STEP_FLOAT;
                        ResetTimer();
                        bFirst = TRUE;
                    }
                    break;
                case CHARGE_STEP_FLOAT:
                    dwdTmp = stChargeCfgData.U6;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    dwdTmp = stChargeCfgData.I6;
                    dwdTmp *= PWM_VAL_MAX;
                    wdIPwm = dwdTmp/awdCurTypeValue[byCurType];

                    bSWRyOut = TRUE;
                    bSWMosOn = TRUE;
                    bSWPowerON = TRUE;
                    wdT6 = GetTimer()/60;

                    bFirst = FALSE;
                    #if DEBUG_CHARGE
                    if (!((dwdDbgCnt+1) % 500)) 
                    {
                        byState = CTRL_STATE_IDLE;
                        ResetTimer();
                        bFirst = TRUE;
                    }
                    #endif

                    if (stChargeCfgData.T6 != 0xffff)
                    {
                        if (wdT6 >= stChargeCfgData.T6)
                        {
                            byState = CTRL_STATE_IDLE;
                            ResetTimer();
                            bFirst = TRUE;
                            bySWCnt = 0;
                            bTurnOff = TRUE;
                            bTurnOn = FALSE;
                        }
                    }
                    break;
                default:
                    byChgStep = CHARGE_STEP_PREV;
                    bFirst = TRUE;
                    ResetTimer();
                    byJudgeWaitCnt = 0;
                    break;
            }

            if ((CTRL_STATE_CHARGE == byState) &&  (byJudgeWaitCnt >= JUDGE_WAIT_TM))
            {
                /* 若电流小于最大充电电流的1/20，说明电池已被拔出 */
                #if DEBUG_CHARGE
                if (0)
                #else
                if (wdCurrent < awdCurTypeValue[byCurType]/20)
                #endif
                {
                    if (byBTTestCnt < 6)
                    {
                        byBTTestCnt ++;
                    }

                    if (byBTTestCnt >= 4)
                    {
                        bSWMosOn = FALSE;
                    }

                    if (byBTTestCnt >= 6)
                    {
                        if (!bBTP)
                        {
                            if (byBTTestCnt < 9)
                            {
                                byBTTestCnt ++;
                            }
                            else
                            {
                                if (!bFirst)
                                {
                                    byState = CTRL_STATE_STAND_BY;
                                    ResetTimer();
                                    bFirst = TRUE;
                                    bySWCnt = 0;
                                    bTurnOff = TRUE;
                                    bTurnOn = FALSE;
                                }
                            }
                        }
                        else
                        {
                            byBTTestCnt = 0;
                        }

                        
                        
                    }
                    
                }
                else
                {
                    byBTTestCnt = 0;
                }
            }

            if (byJudgeWaitCnt < 0xf0)
            {
                byJudgeWaitCnt++;
            }
            
            break;
        case CTRL_STATE_ERROR:
            
            switch (byErr)
            {
                case ERROR_SELF_TEST:
                    /* 如果不开PWM等，将无法检测退出故障状态 */
                    wdIPwm = PWM_VAL_MAX;
                    // wdUPwm = stChargeCfgData.Ucv*(byVoltType+1)*PWM_VAL_MAX*3/awdVoltTypeValue[byVoltType]/4;
                    dwdTmp = stChargeCfgData.Ucv;
                    //dwdTmp *= (byVoltType+1);
                    dwdTmp *= PWM_VAL_MAX*3;
                    dwdTmp /= awdVoltTypeValue[byVoltType];
                    wdUPwm = dwdTmp/4;

                    wdIPwm = PWM_VAL_MAX+10;
                    bSWPowerON = TRUE;
                    
        
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else
                    {
                        if ((wdOutVoltage >= stChargeCfgData.Ucv*9/10) && (wdOutVoltage <= stChargeCfgData.Ucv*11/10))
                        {

                            byState = CTRL_STATE_STAND_BY;
                            byErr = ERROR_NO_ERROR;
                            ResetTimer();
                            bFirst = TRUE;
                            
                        }
                    }
                    break;
                case ERROR_TEMP:
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else
                    {
                    }
                    break;
                case ERROR_BT_REV:
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else
                    {
                        if (!(bACLow || bACOff || bBTN))
                        {
                            byState = CTRL_STATE_STAND_BY;
                            byErr = ERROR_NO_ERROR;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                    }
                    break;
                case ERROR_BT_LOW:
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else
                    {
                        if (!(bACLow || bACOff || bBTP))
                        {
                            byState = CTRL_STATE_STAND_BY;
                            byErr = ERROR_NO_ERROR;
                            ResetTimer();
                            bFirst = TRUE;
                        }
                    }
                    break;
                case ERROR_CFG:
                
                case ERROR_SAVE_DATA:               
                case ERROR_ERROR:
                    if (bFirst)
                    {
                        bFirst = FALSE;
                    }
                    else
                    {
                    }
                    break;
                
            }
            break;
        default:
            byState = CTRL_STATE_STAND_BY;
            ResetTimer();
            bFirst = TRUE;
            break;
    }

}

/* end of file */


