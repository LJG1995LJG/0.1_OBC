###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       19/Nov/2018  00:47:30
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32_USB_OTG_Driver\src\usb_dcd.c
#    Command line =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32_USB_OTG_Driver\src\usb_dcd.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -D USE_STM3210C_EVAL -D
#        USE_USB_OTG_FS -lcN
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\List
#        -o
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "E:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohz --use_c++_inline -I "E:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\List\usb_dcd.lst
#    Object file  =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\Obj\usb_dcd.o
#
###############################################################################

E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32_USB_OTG_Driver\src\usb_dcd.c
      1          /**
      2            ******************************************************************************
      3            * @file    usb_dcd.c
      4            * @author  MCD Application Team
      5            * @version V2.2.1
      6            * @date    17-March-2018
      7            * @brief   Peripheral Device Interface Layer
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; Copyright (c) 2015 STMicroelectronics.
     12            * All rights reserved.</center></h2>
     13            *
     14            * This software component is licensed by ST under Ultimate Liberty license
     15            * SLA0044, the "License"; You may not use this file except in compliance with
     16            * the License. You may obtain a copy of the License at:
     17            *                      <http://www.st.com/SLA0044>
     18            *
     19            ******************************************************************************
     20            */
     21          
     22          /* Includes ------------------------------------------------------------------*/
     23          #include "usb_dcd.h"
     24          #include "usb_bsp.h"
     25          
     26          
     27          /** @addtogroup USB_OTG_DRIVER
     28          * @{
     29          */
     30          
     31          /** @defgroup USB_DCD 
     32          * @brief This file is the interface between EFSL ans Host mass-storage class
     33          * @{
     34          */
     35          
     36          
     37          /** @defgroup USB_DCD_Private_Defines
     38          * @{
     39          */ 
     40          /**
     41          * @}
     42          */ 
     43          
     44          
     45          /** @defgroup USB_DCD_Private_TypesDefinitions
     46          * @{
     47          */ 
     48          /**
     49          * @}
     50          */ 
     51          
     52          
     53          
     54          /** @defgroup USB_DCD_Private_Macros
     55          * @{
     56          */ 
     57          /**
     58          * @}
     59          */ 
     60          
     61          
     62          /** @defgroup USB_DCD_Private_Variables
     63          * @{
     64          */ 
     65          /**
     66          * @}
     67          */ 
     68          
     69          
     70          /** @defgroup USB_DCD_Private_FunctionPrototypes
     71          * @{
     72          */ 
     73          
     74          /**
     75          * @}
     76          */ 
     77          
     78          
     79          /** @defgroup USB_DCD_Private_Functions
     80          * @{
     81          */ 
     82          
     83          
     84          
     85          void DCD_Init(USB_OTG_CORE_HANDLE *pdev , 
     86                        USB_OTG_CORE_ID_TypeDef coreID)
     87          {
     88            uint32_t i;
     89            USB_OTG_EP *ep;
     90            
     91            USB_OTG_SelectCore (pdev , coreID);
     92            
     93            pdev->dev.device_status = USB_OTG_DEFAULT;
     94            pdev->dev.device_address = 0;
     95            
     96            /* Init ep structure */
     97            for (i = 0; i < pdev->cfg.dev_endpoints ; i++)
     98            {
     99              ep = &pdev->dev.in_ep[i];
    100              /* Init ep structure */
    101              ep->is_in = 1;
    102              ep->num = i;
    103              ep->tx_fifo_num = i;
    104              /* Control until ep is activated */
    105              ep->type = EP_TYPE_CTRL;
    106              ep->maxpacket =  USB_OTG_MAX_EP0_SIZE;
    107              ep->xfer_buff = 0;
    108              ep->xfer_len = 0;
    109            }
    110            
    111            for (i = 0; i < pdev->cfg.dev_endpoints; i++)
    112            {
    113              ep = &pdev->dev.out_ep[i];
    114              /* Init ep structure */
    115              ep->is_in = 0;
    116              ep->num = i;
    117              ep->tx_fifo_num = i;
    118              /* Control until ep is activated */
    119              ep->type = EP_TYPE_CTRL;
    120              ep->maxpacket = USB_OTG_MAX_EP0_SIZE;
    121              ep->xfer_buff = 0;
    122              ep->xfer_len = 0;
    123            }
    124            
    125            USB_OTG_DisableGlobalInt(pdev);
    126          
    127          #if defined (STM32F446xx) || defined (STM32F469_479xx)
    128            
    129            /* Force Device Mode*/
    130            USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
    131            
    132            /*Init the Core (common init.) */
    133            USB_OTG_CoreInit(pdev);
    134          
    135          #else
    136            
    137              /*Init the Core (common init.) */
    138            USB_OTG_CoreInit(pdev);
    139          
    140            /* Force Device Mode*/
    141            USB_OTG_SetCurrentMode(pdev, DEVICE_MODE);
    142          
    143          #endif
    144            
    145            /* Init Device */
    146            USB_OTG_CoreInitDev(pdev);
    147            
    148            /* Enable USB Global interrupt */
    149            USB_OTG_EnableGlobalInt(pdev);
    150          }
    151          
    152          
    153          /**
    154          * @brief  Configure an EP
    155          * @param pdev : Device instance
    156          * @param epdesc : Endpoint Descriptor
    157          * @retval : status
    158          */
    159          uint32_t DCD_EP_Open(USB_OTG_CORE_HANDLE *pdev , 
    160                               uint8_t ep_addr,
    161                               uint16_t ep_mps,
    162                               uint8_t ep_type)
    163          {
    164            USB_OTG_EP *ep;
    165            
    166            if ((ep_addr & 0x80) == 0x80)
    167            {
    168              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
    169            }
    170            else
    171            {
    172              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
    173            }
    174            ep->num   = ep_addr & 0x7F;
    175            
    176            ep->is_in = (0x80 & ep_addr) != 0;
    177            ep->maxpacket = ep_mps;
    178            ep->type = ep_type;
    179            if (ep->is_in)
    180            {
    181              /* Assign a Tx FIFO */
    182              ep->tx_fifo_num = ep->num;
    183            }
    184            /* Set initial data PID. */
    185            if (ep_type == USB_OTG_EP_BULK )
    186            {
    187              ep->data_pid_start = 0;
    188            }
    189            USB_OTG_EPActivate(pdev , ep );
    190            return 0;
    191          }
    192          /**
    193          * @brief  called when an EP is disabled
    194          * @param pdev: device instance
    195          * @param ep_addr: endpoint address
    196          * @retval : status
    197          */
    198          uint32_t DCD_EP_Close(USB_OTG_CORE_HANDLE *pdev , uint8_t  ep_addr)
    199          {
    200            USB_OTG_EP *ep;
    201            
    202            if ((ep_addr&0x80) == 0x80)
    203            {
    204              ep = &pdev->dev.in_ep[ep_addr & 0x7F];
    205            }
    206            else
    207            {
    208              ep = &pdev->dev.out_ep[ep_addr & 0x7F];
    209            }
    210            ep->num   = ep_addr & 0x7F;
    211            ep->is_in = (0x80 & ep_addr) != 0;
    212            USB_OTG_EPDeactivate(pdev , ep );
    213            return 0;
    214          }
    215          
    216          
    217          /**
    218          * @brief  DCD_EP_PrepareRx
    219          * @param pdev: device instance
    220          * @param ep_addr: endpoint address
    221          * @param pbuf: pointer to Rx buffer
    222          * @param buf_len: data length
    223          * @retval : status
    224          */
    225          uint32_t   DCD_EP_PrepareRx( USB_OTG_CORE_HANDLE *pdev,
    226                                      uint8_t   ep_addr,
    227                                      uint8_t *pbuf,                        
    228                                      uint16_t  buf_len)
    229          {
    230            USB_OTG_EP *ep;
    231            
    232            ep = &pdev->dev.out_ep[ep_addr & 0x7F];
    233            
    234            /*setup and start the Xfer */
    235            ep->xfer_buff = pbuf;  
    236            ep->xfer_len = buf_len;
    237            ep->xfer_count = 0;
    238            ep->is_in = 0;
    239            ep->num = ep_addr & 0x7F;
    240            
    241            if (pdev->cfg.dma_enable == 1)
    242            {
    243              ep->dma_addr = (uint32_t)pbuf;  
    244            }
    245            
    246            if ( ep->num == 0 )
    247            {
    248              USB_OTG_EP0StartXfer(pdev , ep);
    249            }
    250            else
    251            {
    252              USB_OTG_EPStartXfer(pdev, ep );
    253            }
    254            return 0;
    255          }
    256          
    257          /**
    258          * @brief  Transmit data over USB
    259          * @param pdev: device instance
    260          * @param ep_addr: endpoint address
    261          * @param pbuf: pointer to Tx buffer
    262          * @param buf_len: data length
    263          * @retval : status
    264          */
    265          uint32_t  DCD_EP_Tx ( USB_OTG_CORE_HANDLE *pdev,
    266                               uint8_t   ep_addr,
    267                               uint8_t   *pbuf,
    268                               uint32_t   buf_len)
    269          {
    270            USB_OTG_EP *ep;
    271            
    272            ep = &pdev->dev.in_ep[ep_addr & 0x7F];
    273            
    274            /* Setup and start the Transfer */
    275            ep->is_in = 1;
    276            ep->num = ep_addr & 0x7F;  
    277            ep->xfer_buff = pbuf;
    278            ep->dma_addr = (uint32_t)pbuf;  
    279            ep->xfer_count = 0;
    280            ep->xfer_len  = buf_len;
    281            
    282            if ( ep->num == 0 )
    283            {
    284              USB_OTG_EP0StartXfer(pdev , ep);
    285            }
    286            else
    287            {
    288              USB_OTG_EPStartXfer(pdev, ep );
    289            }
    290            return 0;
    291          }
    292          
    293          
    294          /**
    295          * @brief  Stall an endpoint.
    296          * @param pdev: device instance
    297          * @param epnum: endpoint address
    298          * @retval : status
    299          */
    300          uint32_t  DCD_EP_Stall (USB_OTG_CORE_HANDLE *pdev, uint8_t   epnum)
    301          {
    302            USB_OTG_EP *ep;
    303            if ((0x80 & epnum) == 0x80)
    304            {
    305              ep = &pdev->dev.in_ep[epnum & 0x7F];
    306            }
    307            else
    308            {
    309              ep = &pdev->dev.out_ep[epnum];
    310            }
    311          
    312            ep->is_stall = 1;
    313            ep->num   = epnum & 0x7F;
    314            ep->is_in = ((epnum & 0x80) == 0x80);
    315            
    316            USB_OTG_EPSetStall(pdev , ep);
    317            return (0);
    318          }
    319          
    320          
    321          /**
    322          * @brief  Clear stall condition on endpoints.
    323          * @param pdev: device instance
    324          * @param epnum: endpoint address
    325          * @retval : status
    326          */
    327          uint32_t  DCD_EP_ClrStall (USB_OTG_CORE_HANDLE *pdev, uint8_t epnum)
    328          {
    329            USB_OTG_EP *ep;
    330            if ((0x80 & epnum) == 0x80)
    331            {
    332              ep = &pdev->dev.in_ep[epnum & 0x7F];    
    333            }
    334            else
    335            {
    336              ep = &pdev->dev.out_ep[epnum];
    337            }
    338            
    339            ep->is_stall = 0;  
    340            ep->num   = epnum & 0x7F;
    341            ep->is_in = ((epnum & 0x80) == 0x80);
    342            
    343            USB_OTG_EPClearStall(pdev , ep);
    344            return (0);
    345          }
    346          
    347          
    348          /**
    349          * @brief  This Function flushes the FIFOs.
    350          * @param pdev: device instance
    351          * @param epnum: endpoint address
    352          * @retval : status
    353          */
    354          uint32_t  DCD_EP_Flush (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum)
    355          {
    356          
    357            if ((epnum & 0x80) == 0x80)
    358            {
    359              USB_OTG_FlushTxFifo(pdev, epnum & 0x7F);
    360            }
    361            else
    362            {
    363              USB_OTG_FlushRxFifo(pdev);
    364            }
    365          
    366            return (0);
    367          }
    368          
    369          
    370          /**
    371          * @brief  This Function set USB device address
    372          * @param pdev: device instance
    373          * @param address: new device address
    374          * @retval : status
    375          */
    376          void  DCD_EP_SetAddress (USB_OTG_CORE_HANDLE *pdev, uint8_t address)
    377          {
    378            USB_OTG_DCFG_TypeDef  dcfg;
    379            dcfg.d32 = 0;
    380            dcfg.b.devaddr = address;
    381            USB_OTG_MODIFY_REG32( &pdev->regs.DREGS->DCFG, 0, dcfg.d32);
    382          }
    383          
    384          /**
    385          * @brief  Connect device (enable internal pull-up)
    386          * @param pdev: device instance
    387          * @retval : None
    388          */
    389          void  DCD_DevConnect (USB_OTG_CORE_HANDLE *pdev)
    390          {
    391          #ifndef USE_OTG_MODE
    392            USB_OTG_DCTL_TypeDef  dctl;
    393            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
    394            /* Connect device */
    395            dctl.b.sftdiscon  = 0;
    396            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
    397            USB_OTG_BSP_mDelay(3);
    398          #endif
    399          }
    400          
    401          
    402          /**
    403          * @brief  Disconnect device (disable internal pull-up)
    404          * @param pdev: device instance
    405          * @retval : None
    406          */
    407          void  DCD_DevDisconnect (USB_OTG_CORE_HANDLE *pdev)
    408          {
    409          #ifndef USE_OTG_MODE
    410            USB_OTG_DCTL_TypeDef  dctl;
    411            dctl.d32 = USB_OTG_READ_REG32(&pdev->regs.DREGS->DCTL);
    412            /* Disconnect device for 3ms */
    413            dctl.b.sftdiscon  = 1;
    414            USB_OTG_WRITE_REG32(&pdev->regs.DREGS->DCTL, dctl.d32);
    415            USB_OTG_BSP_mDelay(3);
    416          #endif
    417          }
    418          
    419          
    420          /**
    421          * @brief  returns the EP Status
    422          * @param  pdev : Selected device
    423          *         epnum : endpoint address
    424          * @retval : EP status
    425          */
    426          
    427          uint32_t DCD_GetEPStatus(USB_OTG_CORE_HANDLE *pdev ,uint8_t epnum)
    428          {
    429            USB_OTG_EP *ep;
    430            uint32_t Status = 0;  
    431            
    432            if ((0x80 & epnum) == 0x80)
    433            {
    434              ep = &pdev->dev.in_ep[epnum & 0x7F];    
    435            }
    436            else
    437            {
    438              ep = &pdev->dev.out_ep[epnum];
    439            }
    440            
    441            Status = USB_OTG_GetEPStatus(pdev ,ep);
    442          
    443            /* Return the current status */
    444            return Status;
    445          }
    446          
    447          /**
    448          * @brief  Set the EP Status
    449          * @param  pdev : Selected device
    450          *         Status : new Status
    451          *         epnum : EP address
    452          * @retval : None
    453          */
    454          void DCD_SetEPStatus (USB_OTG_CORE_HANDLE *pdev , uint8_t epnum , uint32_t Status)
    455          {
    456            USB_OTG_EP *ep;
    457            
    458            if ((0x80 & epnum) == 0x80)
    459            {
    460              ep = &pdev->dev.in_ep[epnum & 0x7F];    
    461            }
    462            else
    463            {
    464              ep = &pdev->dev.out_ep[epnum];
    465            }
    466            
    467             USB_OTG_SetEPStatus(pdev ,ep , Status);
    468          }
    469          
    470          /**
    471          * @}
    472          */ 
    473          
    474          /**
    475          * @}
    476          */ 
    477          
    478          /**
    479          * @}
    480          */
    481          
    482          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   DCD_DevConnect
         0   -> USB_OTG_BSP_mDelay
       0   DCD_DevDisconnect
         0   -> USB_OTG_BSP_mDelay
       8   DCD_EP_Close
         8   -> USB_OTG_EPDeactivate
       8   DCD_EP_ClrStall
         8   -> USB_OTG_EPClearStall
       8   DCD_EP_Flush
         8   -> USB_OTG_FlushRxFifo
         8   -> USB_OTG_FlushTxFifo
      16   DCD_EP_Open
        16   -> USB_OTG_EPActivate
      16   DCD_EP_PrepareRx
        16   -> USB_OTG_EP0StartXfer
        16   -> USB_OTG_EPStartXfer
       0   DCD_EP_SetAddress
       8   DCD_EP_Stall
         8   -> USB_OTG_EPSetStall
      16   DCD_EP_Tx
        16   -> USB_OTG_EP0StartXfer
        16   -> USB_OTG_EPStartXfer
       0   DCD_GetEPStatus
         0   -> USB_OTG_GetEPStatus
       8   DCD_Init
         8   -> USB_OTG_CoreInit
         8   -> USB_OTG_CoreInitDev
         8   -> USB_OTG_DisableGlobalInt
         0   -> USB_OTG_EnableGlobalInt
         8   -> USB_OTG_SelectCore
         8   -> USB_OTG_SetCurrentMode
       8   DCD_SetEPStatus
         0   -> USB_OTG_SetEPStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?Subroutine0
      34  ?Subroutine1
      16  ?Subroutine2
      10  DCD_DevConnect
       8  DCD_DevDisconnect
      38  DCD_EP_Close
      20  DCD_EP_ClrStall
      24  DCD_EP_Flush
      66  DCD_EP_Open
      62  DCD_EP_PrepareRx
      16  DCD_EP_SetAddress
      20  DCD_EP_Stall
      60  DCD_EP_Tx
      34  DCD_GetEPStatus
     150  DCD_Init
      40  DCD_SetEPStatus

 
 606 bytes in section .text
 
 606 bytes of CODE memory

Errors: none
Warnings: none
